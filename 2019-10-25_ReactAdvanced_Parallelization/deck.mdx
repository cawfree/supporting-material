import { Appear, Notes, Head, Image } from 'mdx-deck';
import { FullscreenCode, Split, SplitRight } from 'mdx-deck/layouts';
import { CodeSurfer } from 'mdx-deck-code-surfer'
import Lottie from 'react-lottie';

export { dark as theme } from 'mdx-deck/themes';

import morphing from './static/lottie/morphing.json';
import floating from './static/lottie/floating.json';
import cogs from './static/lottie/cogs.json';

import ReactAdvanced from './components/ReactAdvanced';

<Head>
  <title>Threading in React Native: A bridge too far?</title>
</Head>

<ReactAdvanced>

<div
  style={{
    width: '100vw',
    height: '100vh',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 5,
    flexDirection: 'column',
  }}
>

# Threading in React Native

<Lottie
  options={{
    loop: true,
    autoplay: true,
    animationData: cogs,
    rendererSettings: {
      preserveAspectRatio: 'xMidYMid slice',
    },
  }}
  width="30vw"
  height="30vw"
/>

</div>

</ReactAdvanced>

---

<ReactAdvanced>

# Hey, üëãüèª I'm Alex!

<img
  style={{
    borderRadius: 200,
    width: 400,
    height: 400,
  }}
  src="./static/images/alex.png"
/>

</ReactAdvanced>

<Notes
>

Hey everyone! My name is Alex and I'm the creator of the Android and iOS application Mapsy, which is a live social map of the world, powered by React Native.

I've been passionate about software development for the past twelve years, but I've only been an active open source contributor for the past two, which makes today my first ever technical conference!

I'm extremely honoured to speak with you all today, and please can I just ask you all to remember that if I _do_ make any mistakes, like throw up on stage or something... try to go easy on me.

</Notes>

---

<ReactAdvanced>

<div
  style={{
    width: '70vw',
    height: '100vh',
    padding: 10,
  }}
>

# ‚ö° Threading.
  - JavaScript is inherently _synchronous_.
  - Devices are becoming increasingly _parallel_.
  - Users have _high expectations_ of native apps.

</div>

<div
  style={{
    position: 'absolute',
    top: 0,
    right: 0,
    width: '30vw',
    height: '100vh',
    display: 'flex',
    alignItems: 'center',
  }}
>
  <Lottie
    options={{
      loop: true,
      autoplay: true,
      animationData: floating,
      rendererSettings: {
        preserveAspectRatio: 'xMidYMid slice',
      },
    }}
    width="30vw"
    height="30vw"
  />
</div>

</ReactAdvanced>


<Notes
>
  - JavaScript is inherently _synchronous_.
    - We have a single JavaScript thread that is responsible for the execution of all of our logic. And, even when we perform actions which from the outside may _appear_ asynchronous, such as the invocation of a `Promise` or a call to `setTimeout`, JavaScript is merely providing the _illusion_ of asynchrony. Even the _truly_ asynchronous operations, such as network calls using ajax; these are merely bookended by synchronous callbacks in JavaScript.
  - [and yet,] Devices are becoming increasingly _parallel_.
    - The iPhone 11 packs the A13 Bionic CPU; a six-core processor, and the latest Samsung Galaxy carries a whopping eight cores. These manufacturing superpowers clearly recognise the gains in computing power that can be achieved through multiprocessing. Likewise, this also demonstrates that these market leaders acnkowledge the demand of software developers to utilise even more background computation than ever before.
  - [and finally,] Users have very high expectations of native apps.
    - They don't just sit patiently through a download from the App Store for nothing; there's an _implicit expectation_ that a native app should be capable of achieving what the browser couldn't; and that includes taking advantage of the runtime system for all it's worth.

</Notes>

---

<ReactAdvanced>

<div
  style={{
    width: '100vw',
    height: '100vh',
    padding: 5,
  }}
>

# ‚ò†Ô∏è  Pick your Poison.

  - **Native Code** (Objective C, Java, etc.)
    - Highest performance, highest complexity.
  - ** Delegate** to a `<WebView />`
    - Simple, subject to browser fragmentation.
  - **Hybrid Containers**
    - Dedicated threaded JavaScript.

</div>

<Notes
>
  - **Native Code**
    - There are no limits to what can be achieved with the native runtime using the RN bridge. Therefore, it's perfectly possible to deploy tuned, threaded equivalents equivalents of your most computationally-intense code to the native application, which will achieve the highest performance.
    - However, this high performance comes with a severe tradeoff in implementation complexity; as they require both nontrivial development and test effort, _and_ dedicated implementations per-platform for all you polyglots.
    - In addition, normally the nature of designing threaded computation is that you usually want to spin up new workers for ad-hoc tasks whilst you develop, as the most likely candidates for concurrency usually make themselves known during development time. Because of this, a native implementation is a particularly hard sell for general purpose use.

  - **Delegate**
    - As an alternative solution, what if it was possible to take advantage of an existing JavaScript runtime, and have it compute your code for you?
    - There is a well-known technique of exploiting React Native's `<WebView/>` component as a workhorse for computation. What this boils down to is effectively creating a static webpage which serves the code you'd wish to execute embedded within `<script/>` tags. Provided the functions you wish to access are globally available via the `window` object, we can call them by injecting arguments from your JavaScript thread into the `<WebView/>` container. Similarly, we can receive execution results by listening to `onMessage` callbacks from the `<WebView/>`. And all this, _without_ blocking your own application's JavaScript render thread, which provides noticeable performance improvements.
    - In addition, now that we're working in a webpage, we can access all of the <script/> dependencies we want! You can even take advantage of persistent data using in-browser storage.
    - Since we're exploiting existing engines (every device has a browser), there's no noticeable increase to your compiled application binaries; however, you _are_ subject to browser support fragmentation. In addition, this isn't _technically_ threaded execution; this is more like spreading your computation across the UI thread.

  - **Hybrid**
    - The best of both worlds, a hybrid container is effectively a full JavaScript runtime which operates independently of your JavaScript thread, in a dedicated native background thread.
    - Since both threads are decoupled, you allow them both to execute as fast as possible.

</Notes>

</ReactAdvanced>

---

<CodeSurfer
  title="Native Thread Example (Android)"
  code={require('./snippets/native.js')}
  lang="java"
  showNumbers={false}
  dark={false}
  steps={[
    { notes: ""},
    { range: [15, 16] },
    { range: [24, 28] },
    { range: [29, 41] },
    { notes: ""},
  ]}
/>

---

<CodeSurfer
  title="<WebView /> Example"
  code={require('./snippets/webview.js')}
  lang="javascript"
  showNumbers={false}
  dark={false}
  steps={[
    { notes: ""},
    { range: [4, 5] },
    { range: [25, 36] },
    { range: [6, 14] },
    { notes: ""},
  ]}
/>

---

<CodeSurfer
  title="Hybrid Example"
  code={require('./snippets/hybrid.js')}
  lang="javascript"
  showNumbers={false}
  dark={false}
  steps={[
    { notes: ""},
    { range: [3, 3] },
    { range: [5, 5] },
    { range: [13, 18] },
    { range: [7, 11] },
    { range: [22, 22] },
    { range: [23, 30] },
    { notes: ""},
  ]}
/>
